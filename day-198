Given an array stones[], where the ith element represents the number of stones in the ith pile.
In one move, you can merge exactly k consecutive piles into a single pile, and the cost of this move is equal to the total number of stones in these k piles.
Determine the minimum total cost required to merge all the piles into one single pile. If it is not possible to merge all piles into one according to the given rules, return -1.

Examples:

Input: stones[] = [1, 2, 3], k = 2
Output: 9
Explanation: Initially the array looks like [1, 2, 3].
First, we merge first 2 stones, i.e., 1 and 2, array becomes [3, 3] and cost is 1 + 2 = 3.
Then, we merge remaining stones, i.e., 3 and 3, array becomes [6] and the cost = 3 + 3 = 6.
Total cost = 3 + 6 = 9.
Input: stones[] = [1, 5, 3, 2, 4], k = 2
Output: 35
Explanation: Initially the array looks like [1, 5, 3, 2, 4].
First, we merge 1 and 5, array becomes [6, 3, 2, 4] and cost is 1 + 5 = 6.
Then, we merge 3 and 2, array becomes [6, 5, 4] and the cost = 3 + 2 = 5.
Then, we merge 5 and 4, array becomes [6, 9] and the cost = 5 + 4 = 9.
Finally, we merge 6 and 9, array becomes [15] and the cost = 6 + 9 = 15.
Total cost = 6 + 5 + 9 + 15 = 35.
Input: stones[] = [1, 5, 3, 2, 4], k = 4
Output: -1
Explanation: There is no possible way to combine the stones in piles of 4 to get 1 stone in the end.


solutions:


  class Solution {
    public static int mergeStones(int[] stones, int k) {
        int n = stones.length;
        // Feasibility check:
        if ((n - 1) % (k - 1) != 0) return -1;

        // prefix sums
        long[] pref = new long[n + 1];
        for (int i = 0; i < n; i++) pref[i + 1] = pref[i] + stones[i];

        // dp[i][j] = min cost to merge stones[i..j] into the minimal possible number of piles
        long[][] dp = new long[n][n];
        final long INF = Long.MAX_VALUE / 4;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) dp[i][j] = 0L;
        }

        // len = interval length
        for (int len = 2; len <= n; len++) {
            for (int i = 0; i + len - 1 < n; i++) {
                int j = i + len - 1;
                dp[i][j] = INF;
                // try splits; we only need to consider splits m where left and right can be reduced properly
                // stepping by (k-1) enforces the number-of-piles compatibility
                for (int m = i; m < j; m += (k - 1)) {
                    long left = dp[i][m];
                    long right = dp[m + 1][j];
                    if (left == INF || right == INF) continue;
                    dp[i][j] = Math.min(dp[i][j], left + right);
                }
                // If this interval can be merged into 1 pile, add the interval sum
                if ((j - i) % (k - 1) == 0) {
                    dp[i][j] = dp[i][j] == INF ? INF : dp[i][j] + (pref[j + 1] - pref[i]);
                }
            }
        }

        long ans = dp[0][n - 1];
        return ans >= INF ? -1 : (int) ans;
    }

    // quick main for local testing (optional)
    public static void main(String[] args) {
        System.out.println(mergeStones(new int[]{1, 2, 3}, 2)); // 9
        System.out.println(mergeStones(new int[]{3,2,4,1}, 2)); // example more
    }
}




  
