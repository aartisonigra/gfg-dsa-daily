Given an undirected, connected graph with V vertices numbered from 0 to V-1 and E double-edges, represented as a 2D array edges[][]. Each double-edge is represented by a tuple (x, y, w1, w2), which indicates that there are two edges between vertices x and y: a straight edge with weight w1 and a curved edge with weight w2.

You are given two vertices a and b and you have to go from a to b through a series of edges such that in the entire path, you can use at most 1 curved edge. Your task is to find the shortest path from a to b satisfying the above condition.
If no such path exists that satisfies this restriction, return -1.

Note: It is guaranteed that the shortest path value will fit in a 32-bit integer.

Examples:

Input: V = 4, E = 4, a = 1, b = 3, edges[][] = [[0, 1, 1, 4], [0, 2, 2, 4], [0, 3, 3, 1], [1, 3, 6, 5]]

Output: 2
Explanation:
We can follow the path 1 -> 0 -> 3, this gives a distance of 1+3 = 4 if we follow all straight paths. But we can take the curved path  from 0 -> 3, which costs 1. This will result in a cost of 1 + 1 = 2.
Input: V = 2, E = 1, a = 0, b = 1, edges[][] = [[0, 1, 4, 1]]

Output: 1
Explanation:
Take the curved path from 0 to 1 which costs 1. 

Constraints:
1 ≤ V ≤ 106
0 ≤ E ≤ 106
0 ≤ a, b ≤ V - 1
0 ≤ edges[i][0], edges[i][1] ≤ V-1
0 ≤ edges[i][2], edges[i][3] ≤ 104


  SOLUTIONS:

class Solution {
    private static final long INF = Long.MAX_VALUE / 4;
        
    static class Edge {
        int to;
        int w;
        Edge(int to, int w) { this.to = to; this.w = w; }
    }
        
    static class Node implements Comparable<Node> {
        int v;
        int usedCurved;
        long dist;
        Node(int v, int usedCurved, long dist) { this.v = v; this.usedCurved = usedCurved; this.dist = dist; }
        public int compareTo(Node o) { return Long.compare(this.dist, o.dist); }
    }
        
    public int shortestPath(int V, int a, int b, int[][] edges) {
        List<List<Edge>> straight = new ArrayList<>(V);
        List<List<Edge>> curved = new ArrayList<>(V);
        for (int i = 0; i < V; i++) {
            straight.add(new ArrayList<>());
            curved.add(new ArrayList<>());
        }
            
        for (int[] e : edges) {
            int x = e[0], y = e[1], w1 = e[2], w2 = e[3];
            straight.get(x).add(new Edge(y, w1));
            straight.get(y).add(new Edge(x, w1));
            curved.get(x).add(new Edge(y, w2));
            curved.get(y).add(new Edge(x, w2));
        }
            
        long[][] dist = new long[V][2];
        for (int i = 0; i < V; i++) {
            dist[i][0] = dist[i][1] = INF;
        }
        PriorityQueue<Node> pq = new PriorityQueue<>();
        dist[a][0] = 0;
        pq.add(new Node(a, 0, 0));
            
        while (!pq.isEmpty()) {
            Node cur = pq.poll();
            if (cur.dist != dist[cur.v][cur.usedCurved]) continue;
            int v = cur.v;
            int used = cur.usedCurved;
            long d = cur.dist;
                
            for (Edge ed : straight.get(v)) {
                int to = ed.to;
                long nd = d + ed.w;
                if (nd < dist[to][used]) {
                    dist[to][used] = nd;
                    pq.add(new Node(to, used, nd));
                }
            }
             
            if (used == 0) {
                for (Edge ed : curved.get(v)) {
                    int to = ed.to;
                    long nd = d + ed.w;
                    if (nd < dist[to][1]) {
                        dist[to][1] = nd;
                        pq.add(new Node(to, 1, nd));
                    }
                }
            }
        }
            
        long ans = Math.min(dist[b][0], dist[b][1]);
        return (ans >= INF) ? -1 : (int) ans;
    }
}
