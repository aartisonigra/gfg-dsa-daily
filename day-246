You are given two strings, s1 and s2. Your task is to find the smallest substring in s1 such that s2 appears as a subsequence within that substring.

The characters of s2 must appear in the same sequence within the substring of s1.
If there are multiple valid substrings of the same minimum length, return the one that appears first in s1.
If no such substring exists, return an empty string.
Note: Both the strings contain only lowercase english letters.

Examples:

Input: s1 = "geeksforgeeks", s2 = "eksrg"
Output: "eksforg"
Explanation: "eksforg" satisfies all required conditions. s2 is its subsequence and it is smallest and leftmost among all possible valid substrings of s1.
Input: s1 = "abcdebdde", s2 = "bde" 
Output: "bcde"
Explanation:  "bcde" and "bdde" are two substring of s1 where s2 occurs as subsequence but "bcde" occur first so we return that.
Input: s1 = "ad", s2 = "b" 
Output: ""
Explanation: There is no substring exists.


  SOLUTIONS:

class Solution {
    private static final int INF = (int)1e9;
    int[][] dp;
    String s1, s2;
    
    // DERIVED TABULATION FROM MEMOIZATION
    public String minWindow(String s1, String s2) {
        int n = s1.length(), m = s2.length();
        if (m == 0) return "";
        if (n == 0 || m > n) return "";

        // dp[c1][c2] = minimal length of window in s1 starting at c1
        // that contains s2[c2..] as subsequence, or INF if impossible
        int[][] dp = new int[n + 1][m + 1];

        // Initialize base cases:
        // dp[n][c2] = INF for all c2 < m (no chars left but still need to match)
        for (int c2 = 0; c2 < m; c2++) {
            dp[n][c2] = INF;
        }
        // dp[c1][m] = 0 for all c1 (matching empty suffix of s2)
        for (int c1 = 0; c1 <= n; c1++) {
            dp[c1][m] = 0;
        }

        // Fill table bottom-up
        for (int c1 = n - 1; c1 >= 0; c1--) {
            for (int c2 = m - 1; c2 >= 0; c2--) {
                int res;

                if (s1.charAt(c1) == s2.charAt(c2)) {
                    // take
                    int take = dp[c1 + 1][c2 + 1];
                    if (take < INF) take += 1;

                    // skip
                    int skip = dp[c1 + 1][c2];
                    if (skip < INF) skip += 1;

                    res = Math.min(take, skip);
                } else {
                    // only skip
                    int skip = dp[c1 + 1][c2];
                    if (skip < INF) skip += 1;
                    res = skip;
                }

                dp[c1][c2] = res;
            }
        }

        // dp[c1][0] now holds minimal length of window starting at c1
        // that covers full s2
        int bestLen = INF;
        int bestStart = -1;
        for (int c1 = 0; c1 < n; c1++) {
            int len = dp[c1][0];
            if (len < bestLen) {
                bestLen = len;
                bestStart = c1;
            }
        }

        if (bestStart == -1 || bestLen >= INF) return "";
        return s1.substring(bestStart, bestStart + bestLen);
    }
