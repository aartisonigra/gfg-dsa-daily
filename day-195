You are given a square matrix mat[][] of size n Ã— n, where each cell represents either a blocked cell or a cell containing some chocolates. If mat[i][j] equals -1, then the cell is blocked and cannot be visited. Otherwise, mat[i][j] represents the number of chocolates present in that cell.
The task is to determine the maximum number of chocolates a robot can collected by starting from the top-left cell (0, 0), moving to the bottom-right cell (n-1, n-1), and then returning back to (0, 0).
While moving from (0, 0) to (n-1, n-1), the robot can move only in the right (i, j+1) or downward (i+1, j) directions. On the return journey from (n-1, n-1) to (0, 0), it can move only in the left (i, j-1) or upward (i-1, j) directions.

Note: After collecting chocolates from a cell (i, j), that cell becomes empty, meaning mat[i][j] becomes 0 for next visit. If there is no valid path from (0, 0) to (n-1, n-1) or for the return trip, the result should be 0.

Example:

Input: mat[][] = [[0, 1, -1], 
                [1, 1, -1], 
                [1, 1, 2]]
Output: 7
Explanation:
  
One of the optimal paths is to move from (0,0) -> (1,0) -> (2,0) -> (2,1) -> (2,2) while going forward, and then from (2,2) -> (2,1) -> (1,1) -> (0,1) -> (0,0) while coming back. The total number of chocolates collected is 7.
Input: mat[][] = [[1, 1, 0], 
               [1, 1, 1], 
               [0, 1, 1]]
Output: 7
Explanation:
  
One of the optimal paths is to move from (0,0) -> (1,0) -> (2,0) -> (2,1) -> (2,2) while going forward, and then from (2,2) -> (1,2) -> (1,1) -> (0,1) -> (0,0) while coming back. The total number of chocolates collected is 7.
Input: mat[][] = [[1, 0, -1],
                [2, -1, -1],
                [1, -1, 3]]
Output: 0
Explanation:
  
It is impossible to reach the bottom-right cell (2,2) from (0,0) because every route is blocked. Since the destination cannot be reached, the total chocolates collected is 0.


  SOLUTUTIONS:

class Solution {
    public int chocolatePickup(int[][] mat) {
        int n = mat.length;
        int[][][] dp = new int[n][n][n];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                for (int k = 0; k < n; k++)
                    dp[i][j][k] = Integer.MIN_VALUE;

        dp[0][0][0] = mat[0][0] == -1 ? Integer.MIN_VALUE : mat[0][0];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < n; k++) {
                    int l = i + j - k;
                    if (l < 0 || l >= n || mat[i][j] == -1 || mat[k][l] == -1) continue;

                    int val = mat[i][j];
                    if (i != k || j != l) val += mat[k][l];

                    int best = Integer.MIN_VALUE;
                    if (i > 0 && k > 0) best = Math.max(best, dp[i - 1][j][k - 1]);
                    if (i > 0 && l > 0) best = Math.max(best, dp[i - 1][j][k]);
                    if (j > 0 && k > 0) best = Math.max(best, dp[i][j - 1][k - 1]);
                    if (j > 0 && l > 0) best = Math.max(best, dp[i][j - 1][k]);

                    if (best != Integer.MIN_VALUE) dp[i][j][k] = best + val;
                }
            }
        }

        return Math.max(0, dp[n - 1][n - 1][n - 1]);
    }
}
