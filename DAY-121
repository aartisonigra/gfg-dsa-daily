Given an array arr[] of positive integers and an integer k. You have to find the sum of the modes of all the subarrays of size k.
Note: The mode of a subarray is the element that occurs with the highest frequency. If multiple elements have the same highest frequency, the smallest such element is considered the mode.

Examples:

Input: arr[] = [1, 2, 3, 2, 5, 2, 4, 4], k = 3
Output: 13
Explanation: The mode of each k size subarray is [1, 2, 2, 2, 2, 4] and sum of all modes is 13.
Input: arr[] = [1, 2, 1, 3, 5], k = 2
Output: 6
Explanation: The mode of each k size subarray is [1, 1, 1, 3] and sum of all modes is 6.

SOLUTIONS:

import java.util.*;

class Solution {
    private Map<Integer, Integer> freq;                  // value -> frequency
    private Map<Integer, TreeSet<Integer>> bucket;       // frequency -> sorted values
    private int maxFreq;

    public int sumOfModes(int[] arr, int k) {
        if (arr == null || k <= 0 || k > arr.length) return 0;

        // Reset state for each call
        freq = new HashMap<>();
        bucket = new HashMap<>();
        maxFreq = 0;

        long sum = 0L;

        // First window
        for (int i = 0; i < k; i++) {
            add(arr[i]);
        }
        sum += getMode();

        // Slide the window
        for (int i = k; i < arr.length; i++) {
            add(arr[i]);        // add new
            remove(arr[i - k]); // remove old
            sum += getMode();
        }

        return (int) sum;
    }

    private void add(int x) {
        int old = freq.getOrDefault(x, 0);

        // Remove from old bucket
        if (old > 0) {
            TreeSet<Integer> setOld = bucket.get(old);
            setOld.remove(x);
            if (setOld.isEmpty()) {
                bucket.remove(old);
            }
        }

        int now = old + 1;
        freq.put(x, now);

        // Add to new bucket
        bucket.computeIfAbsent(now, t -> new TreeSet<>()).add(x);

        // Update maxFreq
        if (now > maxFreq) maxFreq = now;
    }

    private void remove(int x) {
        int old = freq.get(x);

        // Remove from old bucket
        TreeSet<Integer> setOld = bucket.get(old);
        setOld.remove(x);
        if (setOld.isEmpty()) {
            bucket.remove(old);
        }

        // Update freq map
        if (old == 1) {
            freq.remove(x);
        } else {
            int now = old - 1;
            freq.put(x, now);
            bucket.computeIfAbsent(now, t -> new TreeSet<>()).add(x);
        }

        // Fix maxFreq if needed
        while (maxFreq > 0 && !bucket.containsKey(maxFreq)) {
            maxFreq--;
        }
    }

    private int getMode() {
        while (maxFreq > 0 && !bucket.containsKey(maxFreq)) {
            maxFreq--;
        }
        return bucket.get(maxFreq).first(); // smallest value among maxFreq elements
    }

    // For local testing
    public static void main(String[] args) {
        Solution sol = new Solution();

        int[] arr1 = {1, 2, 3, 2, 5, 2, 4, 4};
        System.out.println(sol.sumOfModes(arr1, 3)); // expected 13

        int[] arr2 = {1, 2, 1, 3, 5};
        System.out.println(sol.sumOfModes(arr2, 2)); // expected 6

        int[] arr3 = {10, 2, 7, 7, 5, 3, 3, 1, 3};
        System.out.println(sol.sumOfModes(arr3, 1)); // expected 41
    }
}
