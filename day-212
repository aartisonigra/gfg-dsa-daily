You are given a string s, and a list of jumps[][] of size n, where each jumps[i] = [s1, s2] denotes that you are allowed to jump from character s1 to s2 in the forward direction.
Additionally, you are allowed to jump forward from a character to any other occurrence of the same character within the string.

You start at index 0 of the string. After every valid jump from index i to index j, where s[i] = s1 and s[j] = s2, you earn a score equal to the sum of ASCII values of all characters between the jump except for the characters equals s2, i.e.

score(i, j) = sum(ascii(s[k]) for i â‰¤ k < j and s[k] != s[j]).

Determine the maximum score that can be achieved by performing a sequence of valid jumps starting from index 0.

Examples:

Input: s = "forgfg", jumps[][] = [['f', 'r'], ['r', 'g']]
Output: 429
Explanation: We can jump from 'f' to 'r' at index 2, this will gives a score equals to sum of ASCII value of 'f', 'o' i.e. 213.
Now we can jump from 'r' to 'g' at index 5, this will gives a score equals to sum of ASCII value of 'r', 'f' i.e. 216.
Hence maximum total score obtain will be 429. 
Input: s = "abcda", jumps[][] = [[b, d]]
Output: 297
Explanation: We can jump from 'a' to 'a'(as both are same character) at index 4, this will gives a score equals to sum of ASCII value of 'b', 'c', 'd' i.e. 297.
Hence maximum total score obtain will be 297. 

  SOLUTIONS:

class Solution {

    public int maxScore(String s, char[][] jumps) {
        int n = s.length();
        if (n == 0) return 0;
        Set<Character> uniq = new HashSet<>();
        for (char c : s.toCharArray()) uniq.add(c);
        for (char[] jp : jumps) {
            uniq.add(jp[0]);
            uniq.add(jp[1]);
        }
       int k = uniq.size();
        char[] idToChar = new char[k];
        Map<Character,Integer> charToId = new HashMap<>();

        int idx = 0;
        for (char c : uniq) {
            charToId.put(c, idx);
            idToChar[idx] = c;
            idx++;
        }
        long[] ps = new long[n + 1];
        for (int i = 0; i < n; i++) {
            ps[i + 1] = ps[i] + s.charAt(i);
        }
        long[][] prefCount = new long[k][n + 1];
        for (int i = 0; i < n; i++) {
            int cid = charToId.get(s.charAt(i));
            for (int c = 0; c < k; c++) {
                prefCount[c][i + 1] = prefCount[c][i];
            }
            prefCount[cid][i + 1]++;
        }
        boolean[][] canJump = new boolean[k][k];
        for (int c = 0; c < k; c++) canJump[c][c] = true;

        for (char[] jp : jumps) {
            int a = charToId.get(jp[0]);
            int b = charToId.get(jp[1]);
            canJump[a][b] = true;
        }

 
        int[][] jumpList = new int[k][];
        for (int c = 0; c < k; c++) {
            List<Integer> temp = new ArrayList<>();
            for (int d = 0; d < k; d++) if (canJump[c][d]) temp.add(d);
            jumpList[c] = temp.stream().mapToInt(x -> x).toArray();
        }

        long[] bestVal = new long[k];
        Arrays.fill(bestVal, Long.MIN_VALUE);

        long[] dp = new long[n + 1];
        for (int pos = n - 1; pos >= 0; pos--) {
            int cId = charToId.get(s.charAt(pos));
            long baseSum = ps[pos];

            long bestScore = 0;

            for (int tId : jumpList[cId]) {
                if (bestVal[tId] == Long.MIN_VALUE) continue;

                long baseCount = prefCount[tId][pos];
                long score = bestVal[tId] + baseCount * idToChar[tId] - baseSum;
                if (score > bestScore) bestScore = score;
            }

            dp[pos] = bestScore;

            long pc = prefCount[cId][pos + 1];
            long val = ps[pos + 1] + dp[pos] - pc * idToChar[cId];

            bestVal[cId] = Math.max(bestVal[cId], val);
        }

        return (int) dp[0];
    }
}
